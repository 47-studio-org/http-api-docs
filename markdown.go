package main

import (
	"bytes"
	"fmt"
	"regexp"
	"strings"
)

type MarkdownFormatter struct{}

func (md *MarkdownFormatter) GenerateIntro() string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, `
# IPFS HTTP API Specification


This document is autogenerated from go-ipfs source code.

`)
	return buf.String()
}

func (md *MarkdownFormatter) GenerateIndex(endps []*Endpoint) string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "## Index\n\n")

	for _, endp := range endps {
		fmt.Fprintf(buf, "  *  [%s](#%s)\n", endp.Name,
			strings.Replace(endp.Name, "/", "", -1))
	}

	fmt.Fprintln(buf)
	fmt.Fprintln(buf)
	return buf.String()
}

func (md *MarkdownFormatter) GenerateEndpointBlock(endp *Endpoint) string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, `
## %s

%s


`, endp.Name, endp.Description)
	return buf.String()
}

func (md *MarkdownFormatter) GenerateArgumentsBlock(args []*Argument, opts []*Argument) string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "### Arguments\n\n")

	if len(args)+len(opts) == 0 {
		fmt.Fprintf(buf, "This endpoint takes no arguments.\n")
	}

	for _, arg := range args {
		if arg.Type != "file" {
			fmt.Fprintf(buf, genArgument(arg, true))
		}
	}
	for _, opt := range opts {
		fmt.Fprintf(buf, genArgument(opt, false))
	}

	fmt.Fprintf(buf, "\n")
	return buf.String()
}

func genArgument(arg *Argument, aliasToArg bool) string {
	buf := new(bytes.Buffer)
	alias := arg.Name
	if aliasToArg {
		alias = "arg"
	}
	fixDesc, _ := regexp.Compile(" Default: [a-zA-z0-9-_]+ ?\\.")
	fmt.Fprintf(buf, "  - `%s` [%s]: %s", alias, arg.Type, fixDesc.ReplaceAll([]byte(arg.Description), []byte("")))
	if len(arg.Default) > 0 {
		fmt.Fprintf(buf, ` Default: "%s".`, arg.Default)
	}
	if arg.Required {
		fmt.Fprintf(buf, ` Required: **yes**.`)
	} else {
		fmt.Fprintf(buf, ` Required: no.`)
	}
	fmt.Fprintln(buf)
	return buf.String()
}

func (md *MarkdownFormatter) GenerateBodyBlock(args []*Argument) string {
	var bodyArg *Argument
	for _, arg := range args {
		if arg.Type == "file" {
			bodyArg = arg
			break
		}
	}

	if bodyArg != nil {
		buf := new(bytes.Buffer)
		fmt.Fprintf(buf, `
### Request Body

This endpoint expects a file in the body of the request as 'multipart/form-data'

`)
		return buf.String()
	}
	return ""
}

func (md *MarkdownFormatter) GenerateResponseBlock(response string) string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, `
### Response

TODO.

`)
	return buf.String()
}

func (md *MarkdownFormatter) GenerateExampleBlock(endp *Endpoint) string {
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "### curl example\n\n")
	fmt.Fprintf(buf, "`")
	fmt.Fprintf(buf, "curl ")

	// Assemble arguments which are not of type file
	var queryargs []string
	hasFileArg := false
	for _, arg := range endp.Arguments {
		q := "arg="
		if arg.Type != "file" {
			q += "<" + arg.Name + ">"
			queryargs = append(queryargs, q)
		} else {
			hasFileArg = true
		}
	}

	// Assemble options
	for _, opt := range endp.Options {
		q := opt.Name + "="
		//if !opt.Required { // Omit non required options
		//	continue
		//}
		if len(opt.Default) > 0 {
			q += opt.Default
		} else {
			q += "<value>"
		}
		queryargs = append(queryargs, q)
	}

	if hasFileArg {
		fmt.Fprintf(buf, "-F file=@myfile ")
	}

	fmt.Fprintf(buf, "\"http://localhost:5001%s", endp.Name)
	if len(queryargs) > 0 {
		fmt.Fprintf(buf, "?%s\"", strings.Join(queryargs, "&"))
	} else {
		fmt.Fprintf(buf, "\"")
	}

	fmt.Fprintf(buf, "`\n\n")
	return buf.String()
}
